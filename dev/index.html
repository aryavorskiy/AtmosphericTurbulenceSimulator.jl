<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Overview · AtmosphericTurbulenceSimulator.jl</title><meta name="title" content="Overview · AtmosphericTurbulenceSimulator.jl"/><meta property="og:title" content="Overview · AtmosphericTurbulenceSimulator.jl"/><meta property="twitter:title" content="Overview · AtmosphericTurbulenceSimulator.jl"/><meta name="description" content="Documentation for AtmosphericTurbulenceSimulator.jl."/><meta property="og:description" content="Documentation for AtmosphericTurbulenceSimulator.jl."/><meta property="twitter:description" content="Documentation for AtmosphericTurbulenceSimulator.jl."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>AtmosphericTurbulenceSimulator.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Overview</a><ul class="internal"><li><a class="tocitem" href="#Installation"><span>Installation</span></a></li><li><a class="tocitem" href="#Basic-usage"><span>Basic usage</span></a></li><li><a class="tocitem" href="#Advanced-options"><span>Advanced options</span></a></li></ul></li><li><a class="tocitem" href="api/">API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Overview</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Overview</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/aryavorskiy/AtmosphericTurbulenceSimulator.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/aryavorskiy/AtmosphericTurbulenceSimulator.jl/blob/master/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Tutorial"><a class="docs-heading-anchor" href="#Tutorial">Tutorial</a><a id="Tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#Tutorial" title="Permalink"></a></h1><p>AtmosphericTurbulenceSimulator provides a Julia toolchain to simulate atmospheric turbulence effects on imaging systems. The package:</p><ul><li>Generates turbulent phase screens following the Kolmogorov model</li><li>Supports efficient high-resolution generation via Harding interpolation</li><li>Simulates telescope imaging with various aperture functions</li><li>Models different true-sky brightness distributions (point sources, binaries, extended objects)</li><li>Outputs results to HDF5 format for analysis</li><li>Supports CPU multi-threading and GPU acceleration (CUDA, etc.)</li></ul><h2 id="Installation"><a class="docs-heading-anchor" href="#Installation">Installation</a><a id="Installation-1"></a><a class="docs-heading-anchor-permalink" href="#Installation" title="Permalink"></a></h2><p>This package is not registered yet. You can install it with the following command in Julia&#39;s REPL:</p><pre><code class="language-julia hljs">using Pkg
Pkg.add(url=&quot;https://github.com/aryavorskiy/AtmosphericTurbulenceSimulator&quot;)</code></pre><h2 id="Basic-usage"><a class="docs-heading-anchor" href="#Basic-usage">Basic usage</a><a id="Basic-usage-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-usage" title="Permalink"></a></h2><h3 id="Phase-screen-generation"><a class="docs-heading-anchor" href="#Phase-screen-generation">Phase screen generation</a><a id="Phase-screen-generation-1"></a><a class="docs-heading-anchor-permalink" href="#Phase-screen-generation" title="Permalink"></a></h3><p>The atmosphere is modeled as a single turbulent layer with phase screens generated according to Kolmogorov statistics:</p><p class="math-container">\[D_\phi(r) = \big\langle (\phi(x) - \phi(x+r))^2 \big\rangle = 6.88 \left( \frac{r}{r_0} \right)^{5/3}.\]</p><p>Here the Fried parameter <span>$r_0$</span> (see <a href="https://doi.org/10.1364/JOSA.55.001427">Fried 1965</a>) controls the turbulence strength. Typically, <span>$r_0$</span> takes values from a few centimeters to tens of centimeters, depending on atmospheric conditions and wavelength; larger <span>$r_0$</span> means weaker aberrations.</p><p>Thus, a single turbulent layer is specified by the grid size and the dimensionless Fried parameter in pixels. Use the <a href="api/#AtmosphericTurbulenceSimulator.SingleLayer"><code>SingleLayer</code></a> constructor:</p><pre><code class="language-julia hljs">using AtmosphericTurbulenceSimulator
# Assume a 2 m telescope, r0 = 0.2 m, grid size 64×64
atm = SingleLayer((64, 64), 0.2 / 2 * 64)
# Using interpolation for 256×256 grid
atm_harding = SingleLayer((256, 256), 0.2 / 2 * 256; interpolate=:auto)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">SingleLayer{Float64, 4}(AtmosphericTurbulenceSimulator.HardingSpec{4}((256, 256), (27, 27)), 25.6)</code></pre><p>Normally the phases are generated using Karhunen-Loève expansion by sampling from a multivariate normal distribution with the appropriate covariance matrix. Since this can be compute-intensive for grids larger than ~32×32, it is recommended to use Harding interpolation (see <a href="https://doi.org/10.1364/AO.38.002161">Harding et al. 1999</a>) for high-resolution screens. One interpolation pass increases the grid size as <span>$N \to 2N - 11$</span>, so multiple passes can be used to reach very high resolutions efficiently. See the <a href="api/#AtmosphericTurbulenceSimulator.SingleLayer"><code>SingleLayer</code></a> documentation for details on interpolation options.</p><p>You can generate and save phase screens to an HDF5 file using <a href="api/#AtmosphericTurbulenceSimulator.simulate_phases-Union{Tuple{AtmosphericTurbulenceSimulator.AtmosphereSpec{FT}}, Tuple{FT}} where FT"><code>simulate_phases</code></a>:</p><pre><code class="language-julia hljs">using Plots, HDF5
simulate_phases(atm_harding; n=128, filename=&quot;phases.h5&quot;)

# Load and visualize a generated phase screen
phases = h5read(&quot;phases.h5&quot;, &quot;phases&quot;, (:, :, 1))
heatmap(phases, colorbar=true, colormap=:viridis, aspect_ratio=:equal, title=&quot;Turbulent Phase Screen&quot;, size=(500, 450))</code></pre><img src="index-5b74e0fe.svg" alt="Example block output"/><h3 id="PSF-simulation"><a class="docs-heading-anchor" href="#PSF-simulation">PSF simulation</a><a id="PSF-simulation-1"></a><a class="docs-heading-anchor-permalink" href="#PSF-simulation" title="Permalink"></a></h3><p>To simulate images, you need to specify the imaging system (aperture, detector) and the true sky brightness distribution. The imaging pipeline convolves the PSF (computed from turbulent phase screens) with the true sky model, optionally adding photon shot noise.</p><p>The aperture function defines the telescope pupil. For a circular aperture with radius <span>$R$</span> on an <span>$N\times N$</span> grid:</p><pre><code class="language-julia hljs">using AtmosphericTurbulenceSimulator

# 64×64 grid, radius 30 pixels
aperture = CircularAperture((64, 64), 30)
img_spec = ImagingSpec(aperture, FilterSpec(550, bandpass=40), nyquist_oversample=1.5)</code></pre><p>The <a href="api/#AtmosphericTurbulenceSimulator.ImagingSpec"><code>ImagingSpec</code></a> combines the aperture with detector parameters. The <code>nyquist_oversample</code> parameter controls image sampling relative to the Nyquist limit (which is twice the diffraction limit), and the <a href="api/#AtmosphericTurbulenceSimulator.FilterSpec"><code>FilterSpec</code></a> is used to define wavelength and bandpass. </p><p>Note that the Nyquist oversampling affects the PSF size, so it does not match the aperture grid size directly. You can specify the imaging grid size explicitly by passing it as a positional argument to <a href="api/#AtmosphericTurbulenceSimulator.ImagingSpec"><code>ImagingSpec</code></a>.</p><div class="admonition is-info" id="Note-bd09bf303e933478"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-bd09bf303e933478" title="Permalink"></a></header><div class="admonition-body"><p>The non-monochromatic PSF simulation assumes the telescope itself is achromatic, i.e., the aperture function does not depend on wavelength. The wavelength dependence only enters through the Fried parameter <span>$r_0(\lambda) \propto \lambda^{6/5}$</span> and the diffraction limit <span>$\lambda / D$</span>. This is a good approximation only for narrow bands.</p></div></div><p>For the true sky, use <a href="api/#AtmosphericTurbulenceSimulator.PointSource"><code>PointSource</code></a> for a single point source, <a href="api/#AtmosphericTurbulenceSimulator.DoubleSystem"><code>DoubleSystem</code></a> for a binary, or <a href="api/#AtmosphericTurbulenceSimulator.TrueSkyImage"><code>TrueSkyImage</code></a> for arbitrary extended objects. The brightness can be specified as a finite photon count (Poisson-sampled) or infinite (continuous flux):</p><pre><code class="language-julia hljs"># Point source: 1e7 photons total, 200 photons/pixel background
ts_point = PointSource(1e7, 200)
# Binary system: secondary offset by (5, 3) pixels, 0.5× intensity
ts_double = DoubleSystem((5, 3), 0.5; nphotons = 1e7, background = 200)
# Custom image from array
img = zeros(Float32, 128, 128)
img[65, 65] = 1.0  # single bright pixel at center
for _ in 1:5
    # random companions around the center
    img[65 + rand(-32:32), 65 + rand(-32:32)] += rand() * 0.1 + 0.05
end
ts_image = TrueSkyImage(img; nphotons=1e7, background=200)</code></pre><p>Finally, combine everything with <a href="api/#AtmosphericTurbulenceSimulator.simulate_images-Union{Tuple{FT2}, Tuple{FT}, Tuple{T}, Tuple{Type{T}, ImagingSpec{FT, AT} where AT&lt;:AbstractMatrix{FT}, AtmosphericTurbulenceSimulator.AtmosphereSpec{FT2}}, Tuple{Type{T}, ImagingSpec{FT, AT} where AT&lt;:AbstractMatrix{FT}, AtmosphericTurbulenceSimulator.AtmosphereSpec{FT2}, AtmosphericTurbulenceSimulator.TrueSky}} where {T, FT, FT2}"><code>simulate_images</code></a> to generate a sequence of turbulence-degraded images:</p><pre><code class="language-julia hljs">using Plots, HDF5, Statistics

# Atmosphere with same grid as aperture
atm = SingleLayer((64, 64), 0.2 / 2 * 64, interpolate=:auto)

# Simulate 128 images
simulate_images(Int32, img_spec, atm, ts_point; n=128, filename=&quot;images.h5&quot;)

# Load and visualize results
images = h5read(&quot;images.h5&quot;, &quot;images&quot;)

p1 = heatmap(images[:, :, 1], title=&quot;Single Frame&quot;, colormap=:jet, aspect_ratio=:equal)
p2 = heatmap(mean(images, dims=3)[:,:,1], title=&quot;128 Frame Average&quot;, colormap=:jet, aspect_ratio=:equal)
plot(p1, p2, layout=(1, 2), size=(900, 450))</code></pre><img src="index-fc0dff51.svg" alt="Example block output"/><p>The output HDF5 file contains:</p><ul><li><code>&quot;images&quot;</code>: simulated images <span>$(N_x, N_y, n)$</span></li><li><code>&quot;aperture&quot;</code>: the aperture function <span>$(N_x, N_y)$</span></li><li><code>&quot;phases&quot;</code>: phase screens <span>$(Np_x, Np_y, n)$</span> (if <code>savephases=true</code>, true by default)</li></ul><h2 id="Advanced-options"><a class="docs-heading-anchor" href="#Advanced-options">Advanced options</a><a id="Advanced-options-1"></a><a class="docs-heading-anchor-permalink" href="#Advanced-options" title="Permalink"></a></h2><h3 id="Batch-size"><a class="docs-heading-anchor" href="#Batch-size">Batch size</a><a id="Batch-size-1"></a><a class="docs-heading-anchor-permalink" href="#Batch-size" title="Permalink"></a></h3><p>Control batch size and HDF5 chunk size for better I/O performance:</p><pre><code class="language-julia hljs">simulate_images(img_spec, atm, ts; n=10000, batch=256, filename=&quot;simulation.h5&quot;)</code></pre><p>The default batch size is 64 images; this is reasonable for most use cases, increase if you have sufficient RAM and run in more than 64 threads or on GPU.</p><h3 id="Multi-threading-and-GPU-acceleration"><a class="docs-heading-anchor" href="#Multi-threading-and-GPU-acceleration">Multi-threading and GPU acceleration</a><a id="Multi-threading-and-GPU-acceleration-1"></a><a class="docs-heading-anchor-permalink" href="#Multi-threading-and-GPU-acceleration" title="Permalink"></a></h3><p>When running large simulations, consider adding more CPU threads:</p><pre><code class="language-bash hljs">julia --threads=auto  # use all available cores</code></pre><p>You can also enable GPU acceleration by specifying a device adapter. For example, to run on an NVIDIA GPU using CUDA.jl:</p><pre><code class="language-julia hljs">using CUDA
# Set up atmosphere, imaging spec, true sky as before
simulate_images(img_spec, atm, ts; n=100_000, deviceadapter=CuArray)  # run on GPU</code></pre><div class="admonition is-warning" id="Warning-9737a986200f261c"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-9737a986200f261c" title="Permalink"></a></header><div class="admonition-body"><p>As of v0.2, only <a href="https://github.com/JuliaGPU/CUDA.jl">CUDA.jl</a> has been tested. <a href="https://github.com/JuliaGPU/AMDGPU.jl">AMDGPU.jl</a> should work without issues, <a href="https://github.com/JuliaGPU/Metal.jl">Metal.jl</a> will not produce PSFs due to missing FFT support. Please open an issue if you encounter problems with these or other backends.</p></div></div><h3 id="Memory-considerations"><a class="docs-heading-anchor" href="#Memory-considerations">Memory considerations</a><a id="Memory-considerations-1"></a><a class="docs-heading-anchor-permalink" href="#Memory-considerations" title="Permalink"></a></h3><p>For very large grids or long runs:</p><ul><li>Use Harding interpolation with <code>interpolate=:auto</code></li><li>Reduce batch size if running out of RAM</li><li>Set <code>savephases=false</code> if phases aren&#39;t needed</li></ul></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="api/">API Reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Thursday 8 January 2026 10:31">Thursday 8 January 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
