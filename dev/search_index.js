var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"Modules = [AtmosphericTurbulenceSimulator]","category":"section"},{"location":"api/#Setting-up-the-atmosphere-model","page":"API Reference","title":"Setting up the atmosphere model","text":"","category":"section"},{"location":"api/#Imaging-specifications","page":"API Reference","title":"Imaging specifications","text":"","category":"section"},{"location":"api/#AtmosphericTurbulenceSimulator.SingleLayer","page":"API Reference","title":"AtmosphericTurbulenceSimulator.SingleLayer","text":"SingleLayer(size, r0[; interpolate, interpolate_from, size_heuristics=1024])\n\nAn AtmosphereSpec that produces independent (uncorrelated) phase frames for each timestep.\n\nArguments\n\nsize: a tuple (nx, ny) specifying the phase screen shape in pixels (coarse sampler grid).\nr0: Fried parameter (r₀) in pixels.\n\nKeyword Arguments\n\ninterpolate: when specified, the phase screen is sampled at a lower resolution and   then upsampled using specified number of Harding interpolation passes. If set to :auto,   the number of passes is chosen such that the low-res grid has at most size_heuristics total pixels.\ninterpolate_from: alternatively, specify the low-res grid size directly. This must be   greater than (11, 11) in each dimension.\nsize_heuristics: when interpolate=:auto, the maximum allowed number of pixels   in the low-res grid. Tweak this based on the capability of your hardware to compute eigen   of a N×N matrix, where N is the number of pixels in the low-res grid.\n\nNotes\n\nThe Harding interpolation follows \"Fast simulation of a Kolmogorov phase screen\" Cressida M. Harding, Rachel A. Johnston, and Richard G. Lane, APPLIED OPTICS Vol. 38, No. 11, April 1999\n\n\n\n\n\n","category":"type"},{"location":"api/#AtmosphericTurbulenceSimulator.kolmogorov_covmat-Tuple{AbstractMatrix}","page":"API Reference","title":"AtmosphericTurbulenceSimulator.kolmogorov_covmat","text":"kolmogorov_covmat(W)\n\nCompute the phase covariance matrix of a turbulent layer in the atmosphere, following the Kolmogorov model. The piston term is excluded in this model. This function assumes unit Fried parameter r0=1.\n\nArguments\n\nW: the aperture function. Either a 2D array, or a (x, y) tuple representing the size   of the aperture (in this case the aperture function is assumed to be a square of this   size).\n\n\n\n\n\n","category":"method"},{"location":"api/#AtmosphericTurbulenceSimulator.simulate_phases-Union{Tuple{AtmosphericTurbulenceSimulator.AtmosphereSpec{FT}}, Tuple{FT}} where FT","page":"API Reference","title":"AtmosphericTurbulenceSimulator.simulate_phases","text":"simulate_phases(phase_sampler::AtmosphereSpec; n, [batch, filename, verbose, deviceadapter])\n\nSimulate n phase screens using the provided atmosphere specification and write the results to an HDF5 file.\n\nArguments\n\natm_spec: an AtmosphereSpec used to produce phase screens.\n\nKeyword Arguments\n\nn: number of phase screens to simulate.\nbatch: batch size for buffered computations and HDF5 writes (default 512).\nfilename: output HDF5 filename (default \"simulation.h5\").\nverbose: show progress meter (true by default).\ndeviceadapter: adapter for device-backed arrays (defaults to Array). To use GPU arrays, pass e.g. CUDA.CuArray here (requires CUDA.jl).\n\n\n\n\n\n","category":"method"},{"location":"api/#AtmosphericTurbulenceSimulator.DoubleSystem","page":"API Reference","title":"AtmosphericTurbulenceSimulator.DoubleSystem","text":"DoubleSystem(rel_position, intensity[; nphotons, background])\n\nModel for a two-component source (binary): primary plus a secondary offset by rel_position. nphotons and background describe the brightness of the primary component; the default is continuous flux, see PointSource for more info.\n\nArguments\n\nrel_position: (dx, dy) integer tuple specifying the secondary's pixel offset.\nintensity: multiplicative intensity of the secondary relative to the primary.\n\n\n\n\n\n","category":"type"},{"location":"api/#AtmosphericTurbulenceSimulator.FilterSpec","page":"API Reference","title":"AtmosphericTurbulenceSimulator.FilterSpec","text":"FilterSpec\n\nRepresentation of a spectral filter used by the imaging pipeline.\n\n\n\nFilterSpec(base_wavelength, wavelengths[, intensities])\n\nArguments\n\nbase_wavelength: central wavelength for the filter.\nwavelengths: vector of sampled wavelengths within the filter bandpass.\nintensities: vector of relative intensities at each sampled wavelength. If not provided, equal weights are assumed.\n\n\n\n\n\n","category":"type"},{"location":"api/#AtmosphericTurbulenceSimulator.FilterSpec-Union{Tuple{T}, Tuple{Type{T}, Real}} where T<:Real","page":"API Reference","title":"AtmosphericTurbulenceSimulator.FilterSpec","text":"FilterSpec([T, ]base_wavelength; bandpass, tcenter=1, tedge=1, npts=7)\n\nArguments\n\nbase_wavelength: central wavelength for the filter (same units as wavelengths).\n\nKeyword Arguments\n\nbandpass: total width of the filter bandpass in wavelength units.\ntcenter: relative intensity at the center wavelength (default 1).\ntedge: relative intensity at the edges of the bandpass (default 1).\n\n\n\n\n\n","category":"method"},{"location":"api/#AtmosphericTurbulenceSimulator.ImagingSpec","page":"API Reference","title":"AtmosphericTurbulenceSimulator.ImagingSpec","text":"ImagingSpec\n\nContainer describing the imaging system configuration. It is defined by the aperture function, the specification of the filter and the output image size. If the image size does not match the aperture size, the aperture is zero-padded accordingly.\n\n\n\nImagingSpec(aperture, [img_size, filter_spec; nyquist_oversample=1])\n\nArguments\n\naperture: 2D aperture (pupil) array describing the telescope pupil.\nimg_size: output image size (nx, ny). If not provided, it is computed as double the size of the aperture times the nyquist_oversample factor.\nfilter_spec: FilterSpec instance describing spectral sampling and relative intensities.\n\n\n\n\n\n","category":"type"},{"location":"api/#AtmosphericTurbulenceSimulator.PointSource","page":"API Reference","title":"AtmosphericTurbulenceSimulator.PointSource","text":"PointSource(nphotons[, background])\nPointSource([;nphotons, background])\n\nSimple true-sky brightness model. When nphotons is finite the simulator will Poisson-sample pixel values according to the PSF-normalized flux with added background; if nphotons is Inf the continuous flux is used (no shot noise), and background is ignored.\n\nArguments\n\nnphotons: total photons for the source (or Inf for continuous mode).\nbackground: constant background added to the flux in photons per pixel.\n\n\n\n\n\n","category":"type"},{"location":"api/#AtmosphericTurbulenceSimulator.TrueSkyImage","page":"API Reference","title":"AtmosphericTurbulenceSimulator.TrueSkyImage","text":"TrueSkyImage(true_sky::AbstractMatrix{T}[; nphotons, background])\n\nWrap a real-valued true-sky image for use with the imaging pipeline. nphotons and background describe the brightness of the source; the default is continuous flux, see PointSource for more info.\n\nArguments\n\ntrue_sky: real image array representing spatial sky brightness.\n\n\n\n\n\n","category":"type"},{"location":"api/#AtmosphericTurbulenceSimulator.CircularAperture-Union{Tuple{T}, Tuple{Type{T}, Tuple{T, T} where T}, Tuple{Type{T}, Tuple{T, T} where T, Any}} where T<:Real","page":"API Reference","title":"AtmosphericTurbulenceSimulator.CircularAperture","text":"CircularAperture([T, ]sz, radius[; aa_dist=1])\n\nCreate a circular (optionally anti-aliased) aperture array of shape sz. Returns a 2D numeric array suitable for use as an aperture in ImagingSpec.\n\nArguments\n\nT: desired numeric element type, Float64 by default.\nsz: aperture size (nx, ny).\nradius: radius of the circular aperture in pixels. Defaults to the largest that fits.\naa_dist: anti-aliasing transition width in pixels at the aperture edge.\n\n\n\n\n\n","category":"method"},{"location":"api/#AtmosphericTurbulenceSimulator.simulate_images-Union{Tuple{FT2}, Tuple{FT}, Tuple{T}, Tuple{Type{T}, ImagingSpec{FT, AT} where AT<:AbstractMatrix{FT}, AtmosphericTurbulenceSimulator.AtmosphereSpec{FT2}}, Tuple{Type{T}, ImagingSpec{FT, AT} where AT<:AbstractMatrix{FT}, AtmosphericTurbulenceSimulator.AtmosphereSpec{FT2}, AtmosphericTurbulenceSimulator.TrueSky}} where {T, FT, FT2}","page":"API Reference","title":"AtmosphericTurbulenceSimulator.simulate_images","text":"simulate_images([T, ]img_spec::ImagingSpec, atm_spec::AtmosphereSpec[, truesky::TrueSky]; n, [batch, filename, verbose, savephases, deviceadapter])\n\nSimulate n images using the provided imaging and atmosphere specifications and write the results to an HDF5 file.\n\nArguments\n\nT: output image numeric type; if not provided, defaults to Int for finite-photon true sky models and Float64 for infinite-photon models.\nimg_spec: an ImagingSpec describing the aperture, image size and filter.\natm_spec: an AtmosphereSpec used to produce phase screens.\ntruesky: a TrueSky model (e.g. PointSource, DoubleSystem, TrueSkyImage).\n\nKeyword Arguments\n\nn: number of images to simulate.\nbatch: batch size for buffered computations and HDF5 writes (default 512).\nfilename: output HDF5 filename (default \"simulation.h5\").\nverbose: show progress meter (true by default).\nsavephases: when true, the sampled phase screens are saved in the HDF5 in dataset with key \"phases\", and the pupil function is saved under key \"aperture\" (true by default).\ndeviceadapter: adapter for device-backed arrays (defaults to Array). To use GPU arrays, pass e.g. CUDA.CuArray here (requires CUDA.jl).\n\n\n\n\n\n","category":"method"},{"location":"#Tutorial","page":"Tutorial","title":"Tutorial","text":"AtmosphericTurbulenceSimulator provides a Julia toolchain to simulate atmospheric turbulence effects on imaging systems. The package:\n\nGenerates turbulent phase screens following the Kolmogorov model\nSupports efficient high-resolution generation via Harding interpolation\nSimulates telescope imaging with various aperture functions\nModels different true-sky brightness distributions (point sources, binaries, extended objects)\nOutputs results to HDF5 format for analysis\nSupports CPU multi-threading and GPU acceleration (CUDA, etc.)","category":"section"},{"location":"#Installation","page":"Tutorial","title":"Installation","text":"This package is not registered yet. You can install it with the following command in Julia's REPL:\n\nusing Pkg\nPkg.add(url=\"https://github.com/aryavorskiy/AtmosphericTurbulenceSimulator\")","category":"section"},{"location":"#Basic-usage","page":"Tutorial","title":"Basic usage","text":"","category":"section"},{"location":"#Phase-screen-generation","page":"Tutorial","title":"Phase screen generation","text":"The atmosphere is modeled as a single turbulent layer with phase screens generated according to Kolmogorov statistics:\n\nD_phi(r) = biglangle (phi(x) - phi(x+r))^2 bigrangle = 688 left( fracrr_0 right)^53\n\nHere the Fried parameter r_0 (see Fried 1965) controls the turbulence strength. Typically, r_0 takes values from a few centimeters to tens of centimeters, depending on atmospheric conditions and wavelength; larger r_0 means weaker aberrations.\n\nThus, a single turbulent layer is specified by the grid size and the dimensionless Fried parameter in pixels. Use the SingleLayer constructor:\n\nusing AtmosphericTurbulenceSimulator\n# Assume a 2 m telescope, r0 = 0.2 m, grid size 64×64\natm = SingleLayer((64, 64), 0.2 / 2 * 64)\n# Using interpolation for 256×256 grid\natm_harding = SingleLayer((256, 256), 0.2 / 2 * 256; interpolate=:auto)\n\nNormally the phases are generated using Karhunen-Loève expansion by sampling from a multivariate normal distribution with the appropriate covariance matrix. Since this can be compute-intensive for grids larger than ~32×32, it is recommended to use Harding interpolation (see Harding et al. 1999) for high-resolution screens. One interpolation pass increases the grid size as N to 2N - 11, so multiple passes can be used to reach very high resolutions efficiently. See the SingleLayer documentation for details on interpolation options.\n\nYou can generate and save phase screens to an HDF5 file using simulate_phases:\n\nusing Plots, HDF5\nsimulate_phases(atm_harding; n=128, filename=\"phases.h5\")\n\n# Load and visualize a generated phase screen\nphases = h5read(\"phases.h5\", \"phases\", (:, :, 1))\nheatmap(phases, colorbar=true, colormap=:viridis, aspect_ratio=:equal, title=\"Turbulent Phase Screen\", size=(500, 450))","category":"section"},{"location":"#PSF-simulation","page":"Tutorial","title":"PSF simulation","text":"To simulate images, you need to specify the imaging system (aperture, detector) and the true sky brightness distribution. The imaging pipeline convolves the PSF (computed from turbulent phase screens) with the true sky model, optionally adding photon shot noise.\n\nThe aperture function defines the telescope pupil. For a circular aperture with radius R on an Ntimes N grid:\n\nusing AtmosphericTurbulenceSimulator\n\n# 64×64 grid, radius 30 pixels\naperture = CircularAperture((64, 64), 30) \nimg_spec = ImagingSpec(aperture, FilterSpec(550, bandpass=40), nyquist_oversample=1.5)\nnothing # hide\n\nThe ImagingSpec combines the aperture with detector parameters. The nyquist_oversample parameter controls image sampling relative to the Nyquist limit (which is twice the diffraction limit), and the FilterSpec is used to define wavelength and bandpass. \n\nNote that the Nyquist oversampling affects the PSF size, so it does not match the aperture grid size directly. You can specify the imaging grid size explicitly by passing it as a positional argument to ImagingSpec.\n\nnote: Note\nThe non-monochromatic PSF simulation assumes the telescope itself is achromatic, i.e., the aperture function does not depend on wavelength. The wavelength dependence only enters through the Fried parameter r_0(lambda) propto lambda^65 and the diffraction limit lambda  D.\n\nFor the true sky, use PointSource for a single point source, DoubleSystem for a binary, or TrueSkyImage for arbitrary extended objects. The brightness can be specified as a finite photon count (Poisson-sampled) or infinite (continuous flux):\n\n# Point source: 1e7 photons total, 200 photons/pixel background\nts_point = PointSource(1e7, 200)\n# Binary system: secondary offset by (5, 3) pixels, 0.5× intensity\nts_double = DoubleSystem((5, 3), 0.5; nphotons = 1e7, background = 200)\n# Custom image from array\nimg = zeros(Float32, 128, 128)\nimg[65, 65] = 1.0  # single bright pixel at center\nfor _ in 1:5\n    # random companions around the center\n    img[65 + rand(-32:32), 65 + rand(-32:32)] += rand() * 0.1 + 0.05\nend\nts_image = TrueSkyImage(img; nphotons=1e7, background=200)\nnothing # hide\n\nFinally, combine everything with simulate_images to generate a sequence of turbulence-degraded images:\n\nusing Plots, HDF5, Statistics\n\n# Atmosphere with same grid as aperture\natm = SingleLayer((64, 64), 0.2 / 2 * 64, interpolate=:auto)\n\n# Simulate 128 images\nsimulate_images(Int32, img_spec, atm, ts_point; n=128, filename=\"images.h5\")\n\n# Load and visualize results\nimages = h5read(\"images.h5\", \"images\")\n\np1 = heatmap(images[:, :, 1], title=\"Single Frame\", colormap=:jet, aspect_ratio=:equal)\np2 = heatmap(mean(images, dims=3)[:,:,1], title=\"128 Frame Average\", colormap=:jet, aspect_ratio=:equal)\nplot(p1, p2, layout=(1, 2), size=(900, 450))\n\nThe output HDF5 file contains:\n\n\"images\": simulated images (N_x N_y n)\n\"aperture\": the aperture function (N_x N_y)\n\"phases\": phase screens (Np_x Np_y n) (if savephases=true, true by default)","category":"section"},{"location":"#Advanced-options","page":"Tutorial","title":"Advanced options","text":"","category":"section"},{"location":"#Batch-size","page":"Tutorial","title":"Batch size","text":"Control batch size and HDF5 chunk size for better I/O performance:\n\nsimulate_images(img_spec, atm, ts; n=10000, batch=256, filename=\"simulation.h5\")\n\nThe default batch size is 64 images; this is reasonable for most use cases, increase if you have sufficient RAM and run in more than 64 threads or on GPU.","category":"section"},{"location":"#Multi-threading-and-GPU-acceleration","page":"Tutorial","title":"Multi-threading and GPU acceleration","text":"When running large simulations, consider adding more CPU threads:\n\njulia --threads=auto  # use all available cores\n\nYou can also enable GPU acceleration by specifying a device adapter. For example, to run on an NVIDIA GPU using CUDA.jl:\n\nusing CUDA\n# Set up atmosphere, imaging spec, true sky as before\nsimulate_images(img_spec, atm, ts; n=100_000, deviceadapter=CuArray)  # run on GPU\n\nwarning: Warning\nAs of v0.2, only CUDA.jl has been tested. AMDGPU.jl should work without issues, Metal.jl will not produce PSFs due to missing FFT support. Please open an issue if you encounter problems with these or other backends.","category":"section"},{"location":"#Memory-considerations","page":"Tutorial","title":"Memory considerations","text":"For very large grids or long runs:\n\nUse Harding interpolation with interpolate=:auto\nReduce batch size if running out of RAM\nSet savephases=false if phases aren't needed","category":"section"}]
}
